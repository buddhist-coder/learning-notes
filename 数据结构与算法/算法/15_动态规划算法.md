# 动态规划算法

- ## 应用场景-背包问题

  背包问题：有一个背包，容量为4磅，现有如下物品：

  | 物品    | 重量 | 价格 |
  | ------- | ---- | ---- |
  | 吉他(G) | 1    | 1500 |
  | 音响(S) | 4    | 3000 |
  | 电脑(L) | 3    | 2000 |

  1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出
  2. 要求装入的物品不能重复

- ## 动态规划算法介绍

  1. 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。
  2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
  3. 与分治算法不同的是，**适用于动态规划求解的问题，经分解得到子问题往往不是相互独立的**。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)。
  4. 动态规划可以通过**填表的方式**来逐步推进，得到最优解。

- ## 背包问题分析

  背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选取物品放入背包是物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）。

  这里的问题属于01背包，即每个物品最多放一个，而无限背包可以转化为01背包。

- ## 思路分析

  算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据`w[i]`和`v[i]`来确定是否需要将该物品放入背包。即对于给定的n个物品，设`v[i]`、`w[i]`分别为第i个物品的价值和重量，C为背包的容量。再令`v[i][j]`表示在前 i 个物品中能够装入容量为 j 的背包的最大值。则有下面的结果：
  
  1. `v[i][0]` = `v[0][j]` = 0；//表示填入表第一行和第一列是0
  
  2. 当`w[i]>j`时：`v[i][j]=v[i-1][j]`；//当准备加入的新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略。
  
  3. 当`j>=w[i]`时：`v[i][j]=max{v[i-1][j],v[i]+v[i-1][j-w[i]]}`；//当准备加入的新增的商品的容量小于等于当前背包的容量，装入的方式：
  
     `v[i-1][j]`：就是上一个单元格的装入的最大值
  
     `v[i]`：当前商品的价值
  
     `v[i-1][j-w[i]]`：装入`i-1`商品，到剩余空间`[j-w[i]`的最大值
  
  填表的过程
  
  | 物品    | 0磅  | 1磅     | 2磅     | 3磅     | 4磅             |
  | ------- | ---- | ------- | ------- | ------- | --------------- |
  |         | 0    | 0       | 0       | 0       | 0               |
  | 吉他(G) | 0    | 1500(G) | 1500(G) | 1500(G) | 1500(G)         |
  | 音响(S) | 0    | 1500(G) | 1500(G) | 1500(G) | 3000(S)         |
  | 电脑(L) | 0    | 1500(G) | 1500(G) | 2000(G) | 1500(G)+2000(G) |
  
- ## 代码案例

  ```java
  package com.xie.algorithm;
  
  import java.util.Arrays;
  
  public class KnapsackProblem {
      public static void main(String[] args) {
          //物品的重量
          int[] w = {1, 4, 3};
          //物品的价值
          int[] val = {1500, 3000, 2000};
          //背包的容量
          int m = 4;
          //物品的个数
          int n = val.length;
  
          //为了记录商品放入的情况，定义一个二维数组
          int[][] path = new int[n + 1][m + 1];
  
          //创建二维数组
          //v[i][j]表示在前 i 个物品中能够装入容量为 j 的背包的最大值
          int[][] v = new int[n + 1][m + 1];
  
          //初始化第一行和第一列
          //将第一列设置为0
          for (int i = 0; i < v.length; i++) {
              v[i][0] = 0;
          }
          //将第一行设置为0
          for (int i = 0; i < v[0].length; i++) {
              v[0][i] = 0;
          }
  
          //根据前面的公式来动态规划处理
          //不处理第一行
          for (int i = 1; i < v.length; i++) {
              //不处理第一列
              for (int j = 1; j < v[0].length; j++) {
                  //公式
                  //因为我们的程序 i  是从1开始的，因此原来的公式中的w[i]修改成w[i-1]
                  if (w[i - 1] > j) {
                      v[i][j] = v[i - 1][j];
                  } else {
                      //因为我们的程序 i  是从1开始的
                      //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                      if (v[i - 1][j] > val[i - 1] + v[i - 1][j - w[i - 1]]) {
                          v[i][j] = v[i - 1][j];
                      } else {
                          v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                          //把当前的情况记录到path
                          path[i][j] = 1;
                      }
                  }
              }
          }
  
          for (int i = 0; i < v.length; i++) {
              System.out.println(Arrays.toString(v[i]));
          }
  
          int i = path.length - 1;
          int j = path[0].length - 1;
          while (i > 0 && j > 0) {
              if (path[i][j] == 1) {
                  System.out.printf("第%d个商品放入背包\n", i);
                  j -= w[i - 1];
              }
              i--;
          }
      }
  
      /**
       * [0, 0, 0, 0, 0]
       * [0, 1500, 1500, 1500, 1500]
       * [0, 1500, 1500, 1500, 3000]
       * [0, 1500, 1500, 2000, 3500]
       * 第3个商品放入背包
       * 第1个商品放入背包
       */
  }
  
  ```
  